= slide 'Днес' do
  list:
    Ruby, ruby, ruby
    SQL в Ruby

= slide 'Drama time', '...again...' do
  p <a href="https://docs.google.com/spreadsheets/d/1mvuFpcBFpTV03UcQ6-2UOcnuLpISBeGGcDPfBRXsrTM/edit#gid=0">Анкетата</a> реши:
  list:
    2 групи - А и Б
    Група А - сряда, 08:00 - 10:00
    Група Б - четвъртък, 19:00 - 21:00
    Остава да намерим стая!

= slide 'Flashback', 'Ruby' do
  list:
    Програмите в Ruby са текстови файлове
    Няма компилация като в C или Java
    Скриптов език
    Изпълняват се в терминал/конзола/command prompt с `ruby име_на_файл`

= slide 'Flashback', 'irb' do
  list:
    `irb` – Interactive Ruby
    REPL — Read-Eval-Print Loop
    Тук ще прекарваме доста време - и ние, и вие
    Стартирате я с `irb` (трябва да ви е в "пътя")
    Самото irb е конзола в конзолата
    Излизате от конзолата с `exit` или с `Ctrl + D` (под UNIX)

= slide 'Flashback', 'syntax 1/2' do
  example:
    [lang:ruby]
      class User
        attr_accessor :username, :email, :first_name, :last_name, :location

        def initialize(username, email, first_name, last_name, location)
          @username = username
          @email = email
          @first_name = first_name
          @last_name = last_name
          @location = location
        end

        def full_name
          "#{first_name} #{last_name}"
        end
      end

= slide 'Flashback', 'syntax 2/2' do
  example:
    [lang:ruby]
    require 'erb'

    require './models/user'

    USERS = {
      1 => User.new('foo', 'foo@example.com', 'Foo', 'Yeah', 'Fooland'),
      2 => User.new('bar', 'bar@example.com', 'Bar', 'Yeah', 'Barland'),
      3 => User.new('larodi', 'larodi@example.com', 'Larodi', 'The Great', 'Larodiland'),
      4 => User.new('lorem', 'lorem@example.com', 'Lorem', 'Text', 'Loremland'),
      5 => User.new('ipsum', 'ipsum@example.com', 'Ipsum', 'Text', 'Ipsumland'),
      6 => User.new('xyz', 'xyz@example.com', 'Xyz', 'abc', 'Xyzland'),
    }

    USER_FOLLOWERS = {
      1 => [2, 3, 5],
    }

    USER_FOLLOWING = {
      1 => [2, 4, 5, 6]
    }

    class UserController
      def show
        @user = USERS[params[:id]]
        render :show
      end

      def followers
        @followers = USER_FOLLOWERS[params[:id]].map { |follower_id| USERS[follower_id] }
        render :followers
      end

      def following
        @following = USER_FOLLOWING[params[:id]].map { |following_id| USERS[following_id] }
        render :following
      end

      private

      def params
        {id: 1}
      end

      def render(view_path)
        view_content = File.read("./views/#{view_path}.html.erb")
        ERB.new(view_content).result(binding)
      end
    end

= slide 'Flashback', 'MVC' do
  img src='images/mvc-rails.png' height=400

= slide 'Gems' do
  list:
    Библиотеки за ruby
    Ruby има пакетен мениджър за тях - RubyGems
    Инсталират се с `gem install gem-name`
    Голямо разнообразие разнообразни
    Често обновявани
    Но как да държим нашият проект в час?
    А какво става, когато работим по няколко проекта?

= slide 'Bundler', 'basics' do
  list:
    Bundler е gem
    За управление на gem-ове
    Предоставя ruby среда за всеки проект

= slide 'Bundler', 'Gemfile' do
  ul
    li Съдържа информация за gem-овете на даден проект
    li Изглежда така:
  example:
    [lang:ruby]
    source 'https://rubygems.org'

    ruby '2.0.0'

    gem 'sequel', '~>4.3'
    gem 'sinatra', '~>1.4'
    gem 'sinatra-contrib', '~>1.4'

= slide 'Bundler', 'начин на работа' do
  list:
    Първо го инсталираме, ако го няма - `gem install bundler`
    `bundler install` - инсталира пакетите опоменати в Gemfile
    `bundle exec` - стартира приложението ни в среда с тези пакети

= slide 'SQL', 'в Ruby' do
  list:
    Няма да преподаваме SQL
    Ще говорим за SQL в Ruby
    Ще говорим за SQL и ролята му в едно уеб приложение

= slide 'SQL', 'какво ще ползваме' do
  list:
    SQLite - SQL Database Engine
    SQLite3 - Ruby gem
    SQLite3 е интерфейс за SQLite

= slide 'SQLite', 'създаване на база данни' do
  ul
    li Създава база (или се свързва, ако вече съществува)
    li Отваря REPL
    li В REPL-то пишем SQL
    li Създадената база е просто файл във файловата система

  example:
    sqlite3 database_name.sqlite3 # Създава база данни (или се свързва, ако съществува)
    sqlite3 database_name.sqlite3 < dump.sql # Така import-ваме SQL (ако не съществува, ще се създаде)

= slide 'Файлова структура', 'update' do
  example:
    .
    |- db
    |  |- database.sqlite3
    |  |- structure.sql
    |
    |- app
    |  |- views
    |  |- controllers
    |  |- models
    |  |- repositories
    |
    |- Gemfile

= slide 'Файлова структура', 'structure.sql' do
  example:
    [lang:sql]
    CREATE TABLE users (
      id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
      first_name TEXT NOT NULL,
      last_name TEXT NOT NULL,
      email TEXT NOT NULL,
      username TEXT NOT NULL,
      location TEXT
    );

= slide 'SQLite', 'таблица users' do
  ul
    li Ще пазим заявките за създаване на таблици в <code>structure.sql</code>
    li Така лесно можем да създадем база с готова, за приложението ни, структура
    li Долното се изпълнява от root директорията на проекта

  p <code>sqlite3 db/database.sqlite3 < db/structure.sql</code>

= slide 'SQLite3', 'свръзване с базата' do
  ul
    li Вече имаме база данни и таблица <code>users</code>
    li Време е да накараме Ruby да комуникира с тях

  example:
    [lang:ruby]
    require 'sqlite3'

    DB = SQLite3::Database.new './db/database.sqlite3'
    DB.execute 'SELECT * FROM users;'

= slide 'Repository класове' do
  list:
    Допълнителен слой (няма общо с MVC), който ние въвеждаме
    Отговорен е за връзката между модел и база данни
    Днес ще имплементираме такъв за User модела

= slide 'CRUD', 'и връзката с HTTP' do
  example:
    Operation        | SQL    | HTTP
    -----------------|--------|----------
    Create           | INSERT | PUT/POST
    Read (Retrieve)  | SELECT | GET
    Update (Modify)  | UPDATE | PUT/PATCH
    Delete (Destroy) | DELETE | DELETE

= slide 'CRUD', 'create' do
  example:
    [lang:ruby]
    require 'sqlite3'

    DB = SQLite3::Database.new './db/database.sqlite3'

    module UserRepository
      extend self

      def create(user)
        DB.execute <<-SQL
          INSERT INTO users (
            `username`, `email`, `first_name`, `last_name`, `location`
          ) VALUES (
            '#{user.username}', '#{user.email}', '#{user.first_name}', '#{user.last_name}', '#{user.location}'
          );
        SQL
      end
    end

= slide 'CRUD', 'find, update, delete' do
  p Идеи?

  example:
    [lang:ruby]
    module UserRepository
      ...
      
      def find(id)
        # ...?
      end

      def update(user)
        # ...?
      end

      def delete(id)
        # ...?
      end
    end

= slide 'CRUD', 'find' do
  example:
    [lang:ruby]
    module UserRepository
      ...
      
      def find(id)
        columns, row = DB.execute2 "SELECT * FROM users WHERE id = #{id};"
        return unless row

        user_attributes = columns.zip(row).to_h
        User.new(
          user_attributes['email'],
          user_attributes['username'],
          user_attributes['first_name'],
          user_attributes['last_name'],
          user_attributes['location'],
        )
      end
    end

= slide 'CRUD', 'update' do
  example:
    [lang:ruby]
    module UserRepository
      ...

      def update(user)
        DB.execute <<-SQL
          UPDATE users
          SET
            username = '#{user.username}',
            email = '#{user.email}',
            first_name = '#{user.first_name}',
            last_name = '#{user.last_name}',
            location = '#{user.location}'
          WHERE id = #{user.id};
        SQL
      end
    end

= slide 'CRUD', 'delete' do
  example:
    [lang:ruby]
    module UserRepository
      ...

      def delete(id)
        DB.execute "DELETE FROM users WHERE id = #{id};"
      end
    end

= slide 'Join Tables', 'followers/following' do
  ul
    li Нека създадем join таблицата <code>users_followers</code>
    li <code>followed_id</code> е този, който го следят
    li <code>follower_id</code> е този, който следи
    li Да си добавим следното в <code>structure.sql</code>

  example:
    [lang:sql]
    CREATE TABLE users_followers (
      id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
      followed_id INTEGER NOT NULL,
      follower_id INTEGER NOT NULL,
      FOREIGN KEY(followed_id) REFERENCES users(id),
      FOREIGN KEY(follower_id) REFERENCES users(id)
    );

= slide 'UserRepository', 'followers/following' do
  p Идеи?

  example:
    [lang:ruby]
    module UserRepository
      ...

      def followers(id)
        # ...?
      end

      def following(id)
        # ...?
      end
    end

= slide 'UserRepository', 'followers/following' do
  example:
    [lang:ruby]
    module UserRepository
      ...

      def followers(id)
        columns, *rows = DB.execute2 <<-SQL
          SELECT email, username, first_name, last_name, location FROM users
          JOIN users_followers
          ON users.id = users_followers.follower_id
          WHERE users_followers.followed_id = #{1};
        SQL

        return unless rows

        rows.map do |row|
          user_attributes = columns.zip(row).to_h

          User.new(
            user_attributes['email'],
            user_attributes['username'],
            user_attributes['first_name'],
            user_attributes['last_name'],
            user_attributes['location'],
          )
        end
      end
    end

= slide 'UserRepository', 'followers/following' do
  example:
    [lang:ruby]
    module UserRepository
      ...

      def following(id)
        # Можете ли сами?
      end
    end

= slide 'UsersController', 'update' do
  p А сега... Да използваме `UserRepository` в `UsersController`
