= slide 'Днес' do
  list:
    Още малко ruby
    Rack
    routing

= slide 'Rack', 'що е то?' do
  list:
    основата на всички модерни Ruby уеб феймуърци
    мидълуеър
    накратко... обще интерфейс между сървъра и приложението

= slide 'Rack', 'в картинки' do
  div.left
    img src='images/intro-rack.jpg' height='400'
  div.right
    img src='images/rack-request-response.png' height='400'

= slide 'Rack application', 'що е то?' do
  list:
    Ruby обект, който отговаря на метода `call`
    приема като аргумент хеш с информация за environment-а
    и връща масив с точно 3 стойности:
    status
    headers
    body

= slide 'Ruby lambdas', 'лирическо отклонение' do
  example:
    [lang:ruby]
    twice = lambda {|x| 2 * x }
    twice.call(5) # => 10

    twice = -> (x) { 2 * x } # 1.9 new syntax
    twice.call(5) # => 10

= slide 'Rack application', 'Здравей свят!' do
  p Създайте файл `config.ru` в root директорията.
  example:
    [lang:ruby]
    # config.ru
    require 'rack'

    run ->(env) { [200, {'ContentType' => 'text/html'}, ['Hello world!']] }

  p Стартира се с `bundle exec rackup`

= slide 'Rack application', 'малки подобрения' do
  example:
    [lang:ruby]
    # config.ru
    require 'rack'

    run ->(env) { Rack::Response.new('Hello world!') }

= slide 'Rack application', 'малко по-ООП' do
  example:
    [lang:ruby]
    # config.ru
    require 'rack'

    module Tweeter
      class Application
        def self.call(env)
          Rack::Response.new env
        end
      end
    end

  list:
    Но нали имаме контролер!
    Защо не го използваме?!


= slide 'Rack application', 'using controller' do
  example:
    [lang:ruby]
    ...
    require './app/controllers/user_controller'

    module Tweeter
      class Application
        def self.call(env)
          controller = ::UserController.new
          Rack::Response.new controller.show
        end
      end
    end

= slide 'Routing' do
  list:
    накратко...
    свързва заявка с двойка <контролер, метод>
    как можем да го направим?
    ще използваме `env`!!1!

= slide 'env', 'под лупа' do
  list:
    REQUEST_METHOD: The HTTP verb of the request. This is required.
    PATH_INFO: The request URL path, relative to the root of the application.
    QUERY_STRING: Anything that followed ? in the request URL string.
    SERVER_NAME and SERVER_PORT: The server's address and port.
    rack.version: The rack version in use.
    rack.url_scheme: is it http or https?
    rack.input: an IO-like object that contains the raw HTTP POST data.
    rack.errors: an object that response to puts, write, and flush.
    rack.session: A key value store for storing request session data.
    rack.logger: An object that can log interfaces. It should implement info, debug, warn, error, and fatal methods.

= slide 'Routing', 'проста имплементация' do
  example:
    [lang:ruby]
    ...
    class Application
      def self.call(env)
        controller = ::UserController.new
        if env['PATH_INFO'] == '/' || env['PATH_INFO'] == '/show'
          Rack::Response.new controller.show
        elsif env['PATH_INFO'] == '/following'
          Rack::Response.new controller.following
        elsif env['PATH_INFO'] == '/followers'
          Rack::Response.new controller.followers
        else
          Rack::Response.new "Page not found!", 404
        end
      end
    end
    ...

= slide 'Routing', 'защо да не използваме switch' do
  example:
    [lang:ruby]
    class Application
      def self.call(env)
        controller = ::UserController.new
        case env['PATH_INFO']
        when '/'
          Rack::Response.new controller.show
        when '/show'
          Rack::Response.new controller.show
        when '/following'
          Rack::Response.new controller.following
        when '/followers'
          Rack::Response.new controller.followers
        else
          Rack::Response.new "Page not found!", 404
        end
      end
    end

= slide 'Сега на къде?', 'или как да надградим' do
  list:
