<!DOCTYPE html><html lang="bg"><head><meta charset="utf-8" /><!--[if lt IE 9]><script src="js/html5shim.js"></script><![endif]--><link href="css/styles.css" rel="stylesheet" /><link href="css/pygments.css" rel="stylesheet" /><script src="js/analytics.js"></script><title>09. REST</title></head><body><header><h1>09. REST</h1><nav><ul><li><button id="prev-btn" title="Previous slide">Previous Slide</button></li><li><span id="slide-number"></span> / <span id="slide-total"></span></li><li><button id="next-btn" title="Next Slide">Next Slide</button></li></ul></nav></header><div id="deck"><section><hgroup><h1>09. REST</h1></hgroup></section><section>
<hgroup><h1>Какво е REST</h1></hgroup>
<ul><li class="action">съкратено от (Representational State Transfer)
</li><li class="action">представен и дефиниран за пръв път през 2000г. от Рой Филдинг в докторската си дисертация
</li><li class="action">представлява архитектурен стил за дизайн на разпределени системи</li></ul></section>
<section>
<hgroup><h1>Ограничителни условия</h1></hgroup>
<ul><li class="action">Наличие на Клиент-сървър архитектура
</li><li class="action">Без статус на сесията (stateless)
</li><li class="action">Кеширане
</li><li class="action">Многослойна система
</li><li class="action">Код при поискване (незадължително)
</li><li class="action">Единен интерфейс</li></ul></section>
<section>
<hgroup><h1>Клиент-сървър архитектура</h1></hgroup>
<ul><li class="action">Клиент-сървър е тип мрежова архитектура, която отделя клиента от сървъра
</li><li class="action">Клиентът и сървърът могат да бъдат заменяни или развивани независимо един от друг, стига това да не налага промяна на единния интерфейс помежду им</li></ul></section>
<section>
<hgroup><h1>Клиент-сървър архитектура</h1></hgroup>
<h2>Характеристика на клиента</h2><ul><li class="action">Подава заявки
</li><li class="action">Изчаква отговор
</li><li class="action">Свързва се до малък брой сървъри едновременно
</li><li class="action">Взаимодейства си с крайните потребители чрез графичен интерфейс</li></ul></section>
<section>
<hgroup><h1>Клиент-сървър архитектура</h1></hgroup>
<h2>Характеристика на сървъра</h2><ul><li class="action">Пасивност (slave)
</li><li class="action">Чака за заявки от клиенти
</li><li class="action">При получаване на заявки, ги обработва и след това отговаря
</li><li class="action">Получава заявки от голямо количество клиенти
</li><li class="action">Не контактува директно с крайният потребител</li></ul></section>
<section>
<hgroup><h1>Без статус на сесията (stateless)</h1></hgroup>
<p>Не е нужно статусите на сесиите на различните потребители да се пазят на сървъра. Всяка заявка от клиента, съдържа в себе си нужната информация за нейната обработка, статуси на сесии се запазват единствено при клиента.</p></section>
<section>
<hgroup><h1>Кеширане</h1></hgroup>
<p>Клиента има право да кешира (запазва) информация, получена в отговор от сървъра, за да я преизползва при последващи заявки. За тази цел сървърът трябва имплицитно или експлицитно да е посочил дали информацията в отговора може да се кешира, за да се избегнат случаи, в които клиентът получава грешна информация при бъдещи заявки. При правилно управление и използване на кеширането могат частично или напълно да се елиминират ненужни взаимодействия между клиента и сървъра, като по този начин се подобрява бързината и производителността.</p></section>
<section>
<hgroup><h1>Многослойна система</h1></hgroup>
<p>Обикновено клиентът не знае дали е свързан с крайния сървър или със сървър-посредник. Сървърите-посредници подобряват ефективността, като увеличават капацитета за обработване на заявки и предоставят споделени кешове. Също така те допринасят да подобряването на сигурността.</p></section>
<section>
<hgroup><h1>Kод при поискване</h1></hgroup>
<p>Сървърът може временно да разшири функционалността, изпращайки код, който се изпълнява директно при клиента. Например клиентски скриптове, написани на JavaScript или компилирани компоненти като Java applets.</p></section>
<section>
<hgroup><h1>Единен интерфейс</h1></hgroup>
<p>Eдинният интерфейс между клиента и сървъра разделя и опростява архитектурата. По този начин всеки компонент може да се развива самостоятелно.</p></section>
<section>
<hgroup><h1>Обобщение</h1></hgroup>
<p>Единственото условие на REST архитектурата, което не е задължително е "Код по поискване". Всяко приложение (услуга), изпълняващо на гореописаните условия, може да се нарече "RESTful". Ако нарушава дори едно от условията, то не може да бъде считано за "RESTful".</p><p>Всяка разпространена хипермедийна система, съответстваща на архитектурния стил на "REST" притежава нужната производителност, мащабируемост(скалируемост), опростеност, гъвкавост, видимост, портативност и надеждност. </p></section>
<section>
<hgroup><h1>Характеристики на REST</h1></hgroup>
<ul><li class="action">Лека алтернатива на SOAP
</li><li class="action">Платформено независим
</li><li class="action">Технологично независим
</li><li class="action">Може лесно да се използва при наличие на firewall
</li><li class="action">Използва HTTP протокола</li></ul></section>
<section>
<hgroup><h1>HTTP протокол</h1></hgroup>
<p>Протокол за трансфер на хипертекст (hypertext transfer protocol) е мрежов протокол, от приложния слой на OSI модела, за пренос на информация в компютърни мрежи. HTTP определя 8 различни клиентски метода за заявки:</p><ul><li class="action">HEAD — иска изпращане на заглавията отговарящи на посочения с URL ресурс. Отговорът на сървъра е идентичен с този на GET, но е с липсващо тяло. По този начин може да се вземе само метаинформацията, свързана с ресурса, спестявайки трансфера на целия файл.
</li><li class="action">GET — с него клиентът прави заявка за ресурс, зададен чрез URL. Могат да се изпращат и ограничено количество данни, закодирани директно в самия URL (отделени чрез въпросителен знак).
</li><li class="action">POST — позволява клиентът да изпрати данни на сървъра. Тази заявка обикновено се генерира при изпращането на уеб формуляр, а данните могат да бъдат: текст, написан от потребителя във формуляра; файл на клиентския компютър и др.
</li><li class="action">PUT — качва файл, който в бъдеще ще отговаря на посочения URL.</li></ul></section>
<section>
<hgroup><h1>HTTP протокол</h1></hgroup>
<ul><li class="action">DELETE — изтрива посочения ресурс.
</li><li class="action">TRACE — сървърът връща получената заявка със статус OK. Позволява да се провери в какъв вид пристига заявката при сървъра и дали (и как) е била модифицирана по трасето от междинни прокси сървъри.
</li><li class="action">OPTIONS — сървърът трябва да отговори с поддържаните от него клиентски методи, съответстващи на зададения URL, или с поддържаните от сървъра методи като цяло, ако е зададено * вместо URL.
</li><li class="action">CONNECT — използва се при комуникация през прокси.</li></ul></section>
<section>
<hgroup><h1>Как работят заявките</h1></hgroup>
<h2>GET заявка на клиента /пример/</h2><ul><li class="action">GET http://bg.wikipedia.org/wiki/HTTP -доставя мрежовия ресурс (файл, скрипт и т.н. които е асоцииран с този URL) 
</li><li class="action">Host: определя Интернет хоста и номера на порта на ресурса, който е заявен. (fi.wikipedia.org)
</li><li class="action">User Agent: съдържа информация за приложението на клиент-хоста, извършващо заявката.
</li><li class="action">Referer: от коя страница е пристигнато на заявения ресурс (от търсачка, друг сайт, ако не е изрично забранено в настройките на браузъра)</li></ul></section>
<section>
<hgroup><h1>Как работят заявките</h1></hgroup>
<h2>Отговор на сървъра </h2><ul><li class="action">Status code: обозначава успешното или неуспешно извършване на заявката.
</li><li class="action">Date: датата и часа на сървъра
</li><li class="action">Expires: „време на годност“ - времето, до което страницата е валидна, т.е. може да бъд„кеширана (запазена локално на клиента или друг прокси или кеш сървър“
</li><li class="action">Server: името на сървърното приложение и версията му   
</li><li class="action">Content-type: тип на документаSet-Cookie:запазва бисквитка (cookie), която бива върната към сървъра при последваща заявка</li></ul></section>
<section>
<hgroup><h1>Как да следим какви заявки се изпращат:</h1></hgroup>
<img src="images/09-rest-curl.jpg" /><ul><li class="action">Chrome developer tools
</li><li class="action">Firefox with firebug
</li><li class="action">curl</li></ul></section>
<section>
<hgroup><h1>HTTP response codes</h1></hgroup>
<ul><li class="action">200 OK - успешна заявка.
</li><li class="action">201 Create - успешна заявка при която е създаден ресурс след PUT или POST заявка.
</li><li class="action">400 Bad Request - неуспешна заявка, обикновено се получава след PUT или POST заявка, когато информацията, която се предава не е минала валидация, не е в правилния формат.
</li><li class="action">401 Unauthorized - нужна е аутентикация преди, за да се достъпи ресурса.
</li><li class="action">404 Not Found - ресурсът не е намерен, получава се в случаи, когато заявката към даден URL адрес не връща ресурс, тъй като, той не се намира там.
</li><li class="action">500 Internal Server Error - обикновено се получава при грешки в сървъра.</li></ul></section>
<section><hgroup><h1>Въпроси</h1></hgroup><ul><li><a href="http://moodle.openfmi.net/course/view.php?id=2261">http://moodle.openfmi.net/course/view.php?id=2261</a></li></ul></section></div><script src="js/jquery-1.5.2.min.js"></script><script src="js/jquery.jswipe-0.1.2.js"></script><script src="js/htmlSlides.js"></script><script src="js/pusher.js"></script><script type="text/javascript">$(function() {
  htmlSlides.init({ hideToolbar: true });
});

mixpanel.set_config({debug: true});

var pusher = new Pusher('a2024b659f492cab86cc');
pusher.subscribe('lectures');
pusher.bind('refresh', function(data) {
  location.reload(true);
});

try {
  mixpanel.track('Landing Page', {
    referrer: document.referrer,
    presentation: document.title
  });
} catch (e) {};</script></body></html>